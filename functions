#!/bin/bash

# MOS FileBrowser Plugin Functions
# Plugin directory
PLG_NAME="mos-file-browser"
PLG_DIR="/var/www/mos-plugins/${PLG_NAME}"
LOGFILE="/var/log/${PLG_NAME}.log"

# Called when the plugin is installed
install() {
    INDEX_FILE="/var/www/index.html"
    LOADER_SCRIPT='<script src="/mos-plugins/mos-file-browser/browser-loader.js"></script>'
    
    # Inject browser loader into index.html if not already present
    if [ -f "$INDEX_FILE" ]; then
        if ! grep -q "mos-file-browser/browser-loader.js" "$INDEX_FILE"; then
            sed -i 's|</head>|    '"$LOADER_SCRIPT"'\n</head>|' "$INDEX_FILE"
        fi
    fi
    
    # Set permissions
    chmod -R 755 /var/www/mos-plugins/mos-file-browser 2>/dev/null || true
    
    # Create symlinks in /usr/bin/plugins for query API access
    mkdir -p /usr/bin/plugins
    ln -sf /usr/bin/ls /usr/bin/plugins/ls 2>/dev/null || true
    ln -sf /usr/bin/cat /usr/bin/plugins/cat 2>/dev/null || true
  ln -sf /usr/bin/head /usr/bin/plugins/head 2>/dev/null || true
  ln -sf /usr/bin/tail /usr/bin/plugins/tail 2>/dev/null || true
  ln -sf /usr/bin/du /usr/bin/plugins/du 2>/dev/null || true
  ln -sf /usr/bin/df /usr/bin/plugins/df 2>/dev/null || true
  ln -sf /usr/bin/stat /usr/bin/plugins/stat 2>/dev/null || true
  ln -sf /usr/bin/file /usr/bin/plugins/file 2>/dev/null || true
  ln -sf /usr/bin/mkdir /usr/bin/plugins/mkdir 2>/dev/null || true
  ln -sf /usr/bin/rm /usr/bin/plugins/rm 2>/dev/null || true
  ln -sf /usr/bin/cp /usr/bin/plugins/cp 2>/dev/null || true
  ln -sf /usr/bin/mv /usr/bin/plugins/mv 2>/dev/null || true
  ln -sf /usr/bin/touch /usr/bin/plugins/touch 2>/dev/null || true
  ln -sf /usr/bin/chmod /usr/bin/plugins/chmod 2>/dev/null || true
  ln -sf /usr/bin/chown /usr/bin/plugins/chown 2>/dev/null || true
  ln -sf /usr/bin/find /usr/bin/plugins/find 2>/dev/null || true
  ln -sf /usr/bin/grep /usr/bin/plugins/grep 2>/dev/null || true
  ln -sf /usr/bin/tar /usr/bin/plugins/tar 2>/dev/null || true
  ln -sf /usr/bin/unzip /usr/bin/plugins/unzip 2>/dev/null || true
  ln -sf /usr/bin/gunzip /usr/bin/plugins/gunzip 2>/dev/null || true
  ln -sf /usr/bin/gzip /usr/bin/plugins/gzip 2>/dev/null || true
  ln -sf /usr/bin/wc /usr/bin/plugins/wc 2>/dev/null || true
  ln -sf /bin/sh /usr/bin/plugins/sh 2>/dev/null || true
  ln -sf /bin/bash /usr/bin/plugins/bash 2>/dev/null || true
  ln -sf /usr/bin/base64 /usr/bin/plugins/base64 2>/dev/null || true
  ln -sf /bin/echo /usr/bin/plugins/echo 2>/dev/null || true
  
  # Create helper script for base64 file decoding
  cat > /usr/bin/plugins/fb-b64decode << 'SCRIPTEOF'
#!/bin/bash
# Decode base64 file to binary
# Usage: fb-b64decode <source.b64> <destination>
if [ $# -lt 2 ]; then
  echo "Usage: fb-b64decode <source> <destination>"
  exit 1
fi
SOURCE="$1"
DEST="$2"
if [ ! -f "$SOURCE" ]; then
  echo "Error: Source file not found: $SOURCE"
  exit 1
fi
base64 -d "$SOURCE" > "$DEST" 2>&1
RESULT=$?
rm -f "$SOURCE" 2>/dev/null
exit $RESULT
SCRIPTEOF
  chmod +x /usr/bin/plugins/fb-b64decode 2>/dev/null || true
  
  # Create helper script to concatenate chunk files into final base64 file
  cat > /usr/bin/plugins/fb-b64cat << 'SCRIPTEOF'
#!/bin/bash
# Concatenate chunk files into base64 temp file, then decode
# Usage: fb-b64cat <output_b64_file> <chunk1> [chunk2] ...
if [ $# -lt 2 ]; then
  echo "Usage: fb-b64cat <output_b64> <chunk1> [chunk2] ..."
  exit 1
fi
OUTPUT="$1"
shift
# Concatenate all chunk files
cat "$@" > "$OUTPUT"
# Remove chunk files
rm -f "$@" 2>/dev/null
exit 0
SCRIPTEOF
  chmod +x /usr/bin/plugins/fb-b64cat 2>/dev/null || true
  
  echo "MOS FileBrowser Plugin installed successfully"
  echo "$(date): Plugin installed" >> "$LOGFILE"
}

# Called when the plugin is uninstalled
uninstall() {
    INDEX_FILE="/var/www/index.html"
    
    # Remove browser loader from index.html
    if [ -f "$INDEX_FILE" ]; then
        sed -i '/mos-file-browser\/browser-loader.js/d' "$INDEX_FILE"
    fi
}

# Called when the plugin is updated
plugin_update() {
    install
}

# Called when MOS starts
mos_start() {
    INDEX_FILE="/var/www/index.html"
    LOADER_SCRIPT='<script src="/mos-plugins/mos-file-browser/browser-loader.js"></script>'
    
    if [ -f "$INDEX_FILE" ]; then
        if ! grep -q "mos-file-browser/browser-loader.js" "$INDEX_FILE"; then
            sed -i 's|</head>|    '"$LOADER_SCRIPT"'\n</head>|' "$INDEX_FILE"
        fi
    fi
}

# Called during an OS or kernel update
mos_osupdate() {
    install
}

# ============================================================================
# File Operations (called via executefunction API)
# ============================================================================

# List directory contents
listdir() {
  local path="${1:-/}"
  if [ -d "$path" ]; then
    ls -la --time-style=long-iso "$path" 2>&1
  else
    echo "ERROR: Directory not found: $path"
    return 1
  fi
}

# Read file content
readfile() {
  local path="$1"
  local maxsize="${2:-1048576}"  # Default 1MB max
  
  if [ ! -f "$path" ]; then
    echo "ERROR: File not found: $path"
    return 1
  fi
  
  local filesize=$(stat -c%s "$path" 2>/dev/null)
  if [ "$filesize" -gt "$maxsize" ]; then
    echo "ERROR: File too large (${filesize} bytes, max ${maxsize})"
    return 1
  fi
  
  cat "$path" 2>&1
}

# Write file content (MOS executefunction passes args via stdin as JSON array)
writefile() {
  local path="$1"
  local content="$2"
  
  # If no direct args, try reading from stdin (MOS executefunction API)
  if [ -z "$path" ]; then
    # Read JSON from stdin: ["path", "content"]
    local json_input
    json_input=$(cat)
    if [ -n "$json_input" ]; then
      # Parse JSON array - extract first and second elements
      path=$(echo "$json_input" | sed 's/^\["//' | sed 's/".*//')
      content=$(echo "$json_input" | sed 's/^[^,]*,"//' | sed 's/"[^"]*$//')
      # Handle escaped characters
      content=$(echo "$content" | sed 's/\\n/\n/g' | sed 's/\\t/\t/g' | sed 's/\\"/"/g')
    fi
  fi
  
  if [ -z "$path" ]; then
    echo "ERROR: No path specified"
    return 1
  fi
  
  # Create parent directory if needed
  mkdir -p "$(dirname "$path")" 2>/dev/null
  
  # Use printf to preserve content exactly (echo might interpret escapes)
  if [ -n "$content" ]; then
    printf '%s' "$content" > "$path" 2>&1
  else
    echo -n > "$path" 2>&1
  fi
  
  if [ $? -eq 0 ]; then
    echo "OK: File saved to $path"
  else
    echo "ERROR: Failed to write file"
    return 1
  fi
}

# Copy file or directory
copyitem() {
  local src="$1"
  local dst="$2"
  
  if [ -z "$src" ] || [ -z "$dst" ]; then
    echo "ERROR: Source and destination required"
    return 1
  fi
  
  if [ ! -e "$src" ]; then
    echo "ERROR: Source not found: $src"
    return 1
  fi
  
  if [ -d "$src" ]; then
    cp -r "$src" "$dst" 2>&1
  else
    cp "$src" "$dst" 2>&1
  fi
  
  if [ $? -eq 0 ]; then
    echo "OK: Copied successfully"
  else
    echo "ERROR: Copy failed"
    return 1
  fi
}

# Move file or directory
moveitem() {
  local src="$1"
  local dst="$2"
  
  if [ -z "$src" ] || [ -z "$dst" ]; then
    echo "ERROR: Source and destination required"
    return 1
  fi
  
  if [ ! -e "$src" ]; then
    echo "ERROR: Source not found: $src"
    return 1
  fi
  
  mv "$src" "$dst" 2>&1
  
  if [ $? -eq 0 ]; then
    echo "OK: Moved successfully"
  else
    echo "ERROR: Move failed"
    return 1
  fi
}

# Delete file or directory
deleteitem() {
  local path="$1"
  local force="${2:-false}"
  
  if [ -z "$path" ]; then
    echo "ERROR: No path specified"
    return 1
  fi
  
  if [ ! -e "$path" ]; then
    echo "ERROR: Path not found: $path"
    return 1
  fi
  
  # Safety check - don't delete critical paths
  case "$path" in
    /|/boot|/etc|/usr|/var|/bin|/sbin|/lib|/lib64)
      echo "ERROR: Cannot delete system directory"
      return 1
      ;;
  esac
  
  if [ -d "$path" ]; then
    if [ "$force" = "true" ]; then
      rm -rf "$path" 2>&1
    else
      rmdir "$path" 2>&1
    fi
  else
    rm "$path" 2>&1
  fi
  
  if [ $? -eq 0 ]; then
    echo "OK: Deleted successfully"
  else
    echo "ERROR: Delete failed"
    return 1
  fi
}

# Create directory
createdir() {
  local path="$1"
  
  if [ -z "$path" ]; then
    echo "ERROR: No path specified"
    return 1
  fi
  
  mkdir -p "$path" 2>&1
  
  if [ $? -eq 0 ]; then
    echo "OK: Directory created"
  else
    echo "ERROR: Failed to create directory"
    return 1
  fi
}

# Calculate directory size
calcsize() {
  local path="$1"
  
  if [ -z "$path" ]; then
    echo "ERROR: No path specified"
    return 1
  fi
  
  if [ ! -e "$path" ]; then
    echo "ERROR: Path not found: $path"
    return 1
  fi
  
  du -sh "$path" 2>&1
}

# Calculate directory size with details
calcsizedetailed() {
  local path="$1"
  local depth="${2:-1}"
  
  if [ -z "$path" ]; then
    echo "ERROR: No path specified"
    return 1
  fi
  
  if [ ! -e "$path" ]; then
    echo "ERROR: Path not found: $path"
    return 1
  fi
  
  du -h --max-depth="$depth" "$path" 2>&1 | sort -hr
}

# Get file info
fileinfo() {
  local path="$1"
  
  if [ -z "$path" ]; then
    echo "ERROR: No path specified"
    return 1
  fi
  
  if [ ! -e "$path" ]; then
    echo "ERROR: Path not found: $path"
    return 1
  fi
  
  echo "=== File Info: $path ==="
  stat "$path" 2>&1
  echo ""
  echo "=== File Type ==="
  file "$path" 2>&1
}

# Rename file or directory
renameitem() {
  local oldpath="$1"
  local newname="$2"
  
  if [ -z "$oldpath" ] || [ -z "$newname" ]; then
    echo "ERROR: Old path and new name required"
    return 1
  fi
  
  if [ ! -e "$oldpath" ]; then
    echo "ERROR: Path not found: $oldpath"
    return 1
  fi
  
  local dir=$(dirname "$oldpath")
  local newpath="${dir}/${newname}"
  
  mv "$oldpath" "$newpath" 2>&1
  
  if [ $? -eq 0 ]; then
    echo "OK: Renamed to $newpath"
  else
    echo "ERROR: Rename failed"
    return 1
  fi
}

# Get disk usage info
diskusage() {
  df -h 2>&1
}

# Search for files
searchfiles() {
  local path="$1"
  local pattern="$2"
  
  if [ -z "$path" ] || [ -z "$pattern" ]; then
    echo "ERROR: Path and pattern required"
    return 1
  fi
  
  find "$path" -name "$pattern" 2>&1 | head -100
}

# Write file content from base64 (for binary files)
writefilebase64() {
  local path="$1"
  local base64content="$2"
  
  # If no direct args, try reading from stdin (MOS executefunction API)
  if [ -z "$path" ]; then
    local json_input
    json_input=$(cat)
    if [ -n "$json_input" ]; then
      path=$(echo "$json_input" | sed 's/^\["//' | sed 's/".*//')
      base64content=$(echo "$json_input" | sed 's/^[^,]*,"//' | sed 's/"[^"]*$//')
    fi
  fi
  
  if [ -z "$path" ]; then
    echo "ERROR: No path specified"
    return 1
  fi
  
  # Create parent directory if needed
  mkdir -p "$(dirname "$path")" 2>/dev/null
  
  if [ -n "$base64content" ]; then
    echo "$base64content" | base64 -d > "$path" 2>&1
  else
    echo "ERROR: No base64 content provided"
    return 1
  fi
  
  if [ $? -eq 0 ]; then
    echo "OK: Binary file saved to $path"
  else
    echo "ERROR: Failed to write binary file"
    return 1
  fi
}

# Compress directory to tar.gz
compressdir() {
  local path="$1"
  local output="$2"
  
  if [ -z "$path" ] || [ -z "$output" ]; then
    echo "ERROR: Path and output required"
    return 1
  fi
  
  if [ ! -d "$path" ]; then
    echo "ERROR: Directory not found: $path"
    return 1
  fi
  
  tar -czf "$output" -C "$(dirname "$path")" "$(basename "$path")" 2>&1
  
  if [ $? -eq 0 ]; then
    echo "OK: Compressed to $output"
  else
    echo "ERROR: Compression failed"
    return 1
  fi
}

# Extract archive
extractarchive() {
  local archive="$1"
  local destdir="$2"
  
  if [ -z "$archive" ]; then
    echo "ERROR: Archive path required"
    return 1
  fi
  
  if [ ! -f "$archive" ]; then
    echo "ERROR: Archive not found: $archive"
    return 1
  fi
  
  destdir="${destdir:-$(dirname "$archive")}"
  
  case "$archive" in
    *.tar.gz|*.tgz)
      tar -xzf "$archive" -C "$destdir" 2>&1
      ;;
    *.tar)
      tar -xf "$archive" -C "$destdir" 2>&1
      ;;
    *.zip)
      unzip -o "$archive" -d "$destdir" 2>&1
      ;;
    *.gz)
      gunzip -k "$archive" 2>&1
      ;;
    *)
      echo "ERROR: Unsupported archive format"
      return 1
      ;;
  esac
  
  if [ $? -eq 0 ]; then
    echo "OK: Extracted to $destdir"
  else
    echo "ERROR: Extraction failed"
    return 1
  fi
}

# Get file/directory owner info
getowner() {
  local path="$1"
  
  if [ -z "$path" ]; then
    echo "ERROR: No path specified"
    return 1
  fi
  
  if [ ! -e "$path" ]; then
    echo "ERROR: Path not found: $path"
    return 1
  fi
  
  stat -c "%U:%G" "$path" 2>&1
}
